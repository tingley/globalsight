/**
 *  Copyright 2009 Welocalize, Inc. 
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  
 *  You may obtain a copy of the License at 
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  
 */
package com.globalsight.everest.edit.offline.page;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.Vector;

import org.apache.log4j.Logger;

import com.globalsight.cxe.adapter.idml.IdmlHelper;
import com.globalsight.everest.comment.CommentManager;
import com.globalsight.everest.comment.Issue;
import com.globalsight.everest.comment.IssueImpl;
import com.globalsight.everest.edit.DisplayMatchTypeKeys;
import com.globalsight.everest.edit.EditHelper;
import com.globalsight.everest.edit.offline.AmbassadorDwUpConstants;
import com.globalsight.everest.edit.offline.OfflineEditHelper;
import com.globalsight.everest.edit.offline.OfflineEditorManagerException;
import com.globalsight.everest.edit.offline.download.DownloadParams;
import com.globalsight.everest.edit.offline.upload.UploadParams;
import com.globalsight.everest.integration.ling.LingServerProxy;
import com.globalsight.everest.integration.ling.tm2.LeverageMatch;
import com.globalsight.everest.integration.ling.tm2.MatchTypeStatistics;
import com.globalsight.everest.integration.ling.tm2.Types;
import com.globalsight.everest.jobhandler.Job;
import com.globalsight.everest.page.ExtractedSourceFile;
import com.globalsight.everest.page.PageManager;
import com.globalsight.everest.page.PageTemplate;
import com.globalsight.everest.page.PageWordCounts;
import com.globalsight.everest.page.SnippetPageTemplate;
import com.globalsight.everest.page.SourcePage;
import com.globalsight.everest.page.TargetPage;
import com.globalsight.everest.projecthandler.TranslationMemoryProfile;
import com.globalsight.everest.servlet.util.ServerProxy;
import com.globalsight.everest.tuv.PageSegments;
import com.globalsight.everest.tuv.PageSegmentsException;
import com.globalsight.everest.tuv.SegmentPair;
import com.globalsight.everest.tuv.Tuv;
import com.globalsight.everest.tuv.TuvState;
import com.globalsight.everest.util.system.SystemConfigParamNames;
import com.globalsight.everest.util.system.SystemConfiguration;
import com.globalsight.everest.webapp.pagehandler.edit.online.EditorHelper;
import com.globalsight.everest.webapp.pagehandler.projects.l10nprofiles.LocProfileStateConstants;
import com.globalsight.ling.common.CodesetMapper;
import com.globalsight.ling.tm.LeverageMatchLingManager;
import com.globalsight.ling.tm2.leverage.LeverageUtil;
import com.globalsight.ling.tm2.leverage.MatchState;
import com.globalsight.ling.tw.internal.InternalTextUtil;
import com.globalsight.machineTranslation.MTHelper;
import com.globalsight.terminology.termleverager.TermLeverageManager;
import com.globalsight.terminology.termleverager.TermLeverageMatchResultSet;
import com.globalsight.util.GeneralException;
import com.globalsight.util.GlobalSightLocale;
import com.globalsight.util.SortUtil;
import com.globalsight.util.StringUtil;
import com.globalsight.util.gxml.GxmlElement;
import com.globalsight.util.gxml.GxmlNames;

/**
 * This class is responsibile for generating PageData objects.
 * 
 * A PageData object holds one PageSegments object (a sever-side-view) and one
 * OfflinePageData object (a client-side-view for download & upload) of all the
 * data related to one offline file.
 * 
 * OfflinePageData's generated by this class are used internally as input to the
 * offline file writers, input to the upload error checker, and input to the
 * Upload Page Saver.
 * 
 * PageSegments are initialy used to build the OfflinePageData (for both upload
 * & download). PageSegments is also passed back to TuvManager during an upload
 * save.
 */
public class OfflinePageDataGenerator implements AmbassadorDwUpConstants
{
    static protected final Logger CATEGORY = Logger
            .getLogger(OfflinePageDataGenerator.class);

    static public final int DEFAULT_MAX_FUZZY = 3;

    // Match type display categories
    static public final int INDICATE_MATCH_TYPE_UNKNOWN = 1;
    static public final int INDICATE_CURRENT_TARGET = 2;
    static public final int INDICATE_CURRENT_TARGET_SUB = 3;
    static public final int INDICATE_CURRENT_TARGET_EXCLUDED = 4;
    static public final int INDICATE_CURRENT_TARGET_SUB_EXCLUDED = 5;
    static public final int INDICATE_EXACT = 6;
    static public final int INDICATE_UNVERIFIED_EXACT = 7;
    static public final int INDICATE_EXACT_SUB = 8;
    static public final int INDICATE_UNVERIFIED_EXACT_SUB = 9;
    static public final int INDICATE_FUZZY_NORMAL = 10;
    static public final int INDICATE_FUZZY_TRADOS = 11;
    static public final int INDICATE_NO_MATCH = 12;

    static public final float SCORE_UNKNOWN = -1;

    static private ResourceBundle m_resources;
    static
    {
        try
        {
            // NOTE: since the keys that appear in the offline file
            // currently cannot be translated without breaking
            // the parser, we will stick to English only VALUES
            // for those keys as well.
            m_resources = ResourceBundle.getBundle(
                    "com/globalsight/resources/messages/EditorMatchTypeLabels",
                    Locale.US);
        }
        catch (MissingResourceException ex)
        {
            CATEGORY.error("can't find resource EditorMatchTypeLabels.");
            // throws unchecked exception
            throw new RuntimeException(ex.toString());
        }
    }

    // Flag saying we collect reference data for download or upload.
    private boolean m_isDownloadRequest = true;

    private int m_tagDisplayFormatID = -1;
    private GlobalSightLocale m_sourceLocale = null;
    private GlobalSightLocale m_targetLocale = null;
    private int m_fileFormatId = -1;

    private String m_pageName = null;
    private boolean m_canUseUrl = false;
    private Map m_mergeOverrideDirectives = null;
    private boolean m_mergeEnabled = false;
    // private int m_downloadEditAll =
    // AmbassadorDwUpConstants.DOWNLOAD_EDITALL_STATE_UNAUTHORIZED;
    // default is to allow edit locked ICE and 100% segments
    private int TMEditType = LocProfileStateConstants.TM_EDIT_TYPE_NONE;
    private Vector m_excludeTypeNames = null;

    private OfflinePageData m_offlinePage = null;
    private SourcePage m_srcPage = null;

    /**
     * Reference to the PageSegments from which the OfflineSegmentData objects
     * are built.
     */
    private PageSegments m_ref_pageSegs = null;

    // Need target page to get words counts.
    private TargetPage m_trgPage = null;
    private Set m_interpretedTuIds = null;
    protected Map m_fuzzyMatchMap = null;
    // GBS-3776
    protected Map m_fuzzyMatchRefTmsMap = null;
    protected Map m_exactMatchMap = null;
    private MatchTypeStatistics m_matchTypeStats = null;
    protected TermLeverageMatchResultSet m_termResultSet = null;
    protected ArrayList m_issues = null;
    private String m_sourcePageIdAsString = null;
    private long m_sourcePageIdAsLong = -1;
    private Long m_targetPageIdAsLong = null;

    private long m_segmentCounter = -1;
    protected int m_maxFuzzyNum = 3; // default 3
    private int m_annotationThreshold = 0; // The max number of segments allowed
                                           // with annotations.
    private long m_lastPid = -1;
    private boolean m_hasMergeOverrideDirectives = false;
    private boolean populateFuzzy = true;
    private boolean populate100 = true;

    private class SubflowData
    {
        String m_parentOfSubTagName = null;
        String m_downloadSubId = null;
        String m_downloadTuId = null;
        GxmlElement m_sub = null;

        public SubflowData(String p_downloadSubId, String p_downloadTuId,
                GxmlElement p_sub, String p_parentOfSubTagName)
        {
            m_downloadSubId = p_downloadSubId;
            m_downloadTuId = p_downloadTuId;
            m_sub = p_sub;
            m_parentOfSubTagName = p_parentOfSubTagName;
        }

        public String getParentOfSubTagName()
        {
            return m_parentOfSubTagName;
        }

        public String getDownloadSubId()
        {
            return m_downloadSubId;
        }

        public String getDownloadTuId()
        {
            return m_downloadTuId;
        }

        public GxmlElement getSub()
        {
            return m_sub;
        }
    }

    protected boolean m_addDeleteEnabled = false;
    protected boolean m_pageHasGsTags = false;

    /** Creates new OfflinePageManagement. */
    public OfflinePageDataGenerator()
    {
        try
        {
            ResourceBundle bundle = ResourceBundle.getBundle(
                    AmbassadorDwUpConstants.OFFLINE_CONFIG_PROPERTY, Locale.US);

            // Override default max number of fuzzy to display.
            String tmp = bundle
                    .getString(AmbassadorDwUpConstants.OFFLINE_CONFIG_KEY_MAX_FUZZY);

            m_maxFuzzyNum = Integer.parseInt(tmp);

            // Override default max number of segments allowed with annotations.
            tmp = bundle
                    .getString(AmbassadorDwUpConstants.OFFLINE_CONFIG_KEY_ATN_THRESHOLD);
            m_annotationThreshold = Integer.parseInt(tmp);

            // Check if Add/Delete is enabled.
            m_addDeleteEnabled = SystemConfiguration.getInstance()
                    .getBooleanParameter(
                            SystemConfigParamNames.ADD_DELETE_ENABLED);
        }
        catch (Exception ex)
        {
            CATEGORY.error("initialization error", ex);
        }
    }

    private void reset()
    {
        m_offlinePage = null;
        m_srcPage = null;
        m_ref_pageSegs = null;
        m_trgPage = null;
        m_interpretedTuIds = null;
        m_fuzzyMatchMap = null;
        m_fuzzyMatchRefTmsMap = null;
        m_matchTypeStats = null;
        m_termResultSet = null;
        m_sourcePageIdAsString = null;
        m_sourcePageIdAsLong = -1;
        m_pageName = null;
        m_canUseUrl = false;
        m_segmentCounter = -1;
        m_maxFuzzyNum = DEFAULT_MAX_FUZZY;
        m_lastPid = -1;
        m_hasMergeOverrideDirectives = false;
        m_mergeEnabled = false;

        m_addDeleteEnabled = false;
        m_pageHasGsTags = false;

        m_tagDisplayFormatID = -1;
        m_sourceLocale = null;
        m_targetLocale = null;
        m_fileFormatId = -1;

        // m_downloadEditAll =
        // AmbassadorDwUpConstants.DOWNLOAD_EDITALL_STATE_UNAUTHORIZED;
        TMEditType = LocProfileStateConstants.TM_EDIT_TYPE_BOTH;
        m_excludeTypeNames = null;
    }

    private boolean isDownloadRequest()
    {
        return m_isDownloadRequest;
    }

    private boolean isUploadRequest()
    {
        return !m_isDownloadRequest;
    }

    private boolean isDownloadForOmegaT()
    {
        return AmbassadorDwUpConstants.DOWNLOAD_FILE_FORMAT_OMEGAT == m_fileFormatId;
    }

    /**
     * @return true if we can use Trados segment markup, false if we cannot.
     */
    public boolean isDownloadForTrados()
    {
        return m_fileFormatId == AmbassadorDwUpConstants.DOWNLOAD_FILE_FORMAT_TRADOSRTF
                || m_fileFormatId == AmbassadorDwUpConstants.DOWNLOAD_FILE_FORMAT_TRADOSRTF_OPTIMIZED;
    }

    /**
     * Gets a PageData holding the raw data for download.
     * 
     * @param p_pageIdAsString
     *            the id of the page to get
     * @param p_pageName
     *            the actual name of the page
     * @param p_canUseUrl
     *            true means there is a preview URL
     * @param p_downloadParams
     *            all download parameters.
     * @return PageData all data relating to one offline file.
     */
    public PageData getDownloadPageData(String p_pageIdAsString,
            String p_pageName, boolean p_canUseUrl,
            DownloadParams p_downloadParams, TargetPage p_trgPage)
            throws GeneralException
    {
        CATEGORY.debug("getDownloadPageData()");
        m_isDownloadRequest = true;
        m_tagDisplayFormatID = p_downloadParams.getTagDisplayFormatID();
        m_sourceLocale = p_downloadParams.getSourceLocale();
        m_targetLocale = p_downloadParams.getTargetLocale();
        m_fileFormatId = p_downloadParams.getFileFormatId();
        m_sourcePageIdAsString = p_pageIdAsString;
        m_sourcePageIdAsLong = Long.parseLong(m_sourcePageIdAsString);
        m_trgPage = p_trgPage;
        m_pageName = p_pageName;
        m_canUseUrl = p_canUseUrl;
        m_mergeEnabled = false;
        // m_downloadEditAll = p_downloadParams.getDownloadEditAllState();
        TMEditType = p_downloadParams.getTMEditType();
        m_excludeTypeNames = (Vector) p_downloadParams.getExcludedTypeNames();
        populateFuzzy = p_downloadParams.isPopulateFuzzy();
        populate100 = p_downloadParams.isPopulate100();
        PageData result = getPageData();
        setHeaderValues(result.getOfflinePageData(), p_downloadParams);

        reset();
        CATEGORY.debug("getDownloadPageData() -- done");
        return result;
    }

    /**
     * @return PageData all data relating to one offline file.
     */
    public PageData getUploadReferencePageData(UploadParams p_uploadParams)
            throws GeneralException
    {
        CATEGORY.debug("getUploadReferencePageData()");
        m_isDownloadRequest = false;

        m_tagDisplayFormatID = p_uploadParams.getTagDisplayFormatID();
        m_sourceLocale = p_uploadParams.getSourceLocale();
        m_targetLocale = p_uploadParams.getTargetLocale();
        m_fileFormatId = p_uploadParams.getFileFormatId();
        m_sourcePageIdAsString = p_uploadParams.getPageId();
        m_sourcePageIdAsLong = Long.parseLong(m_sourcePageIdAsString);
        m_targetPageIdAsLong = p_uploadParams.getTargetPageId();
        m_pageName = p_uploadParams.getPageName();
        m_canUseUrl = p_uploadParams.getCanUseUrl();
        m_mergeOverrideDirectives = p_uploadParams.getMergeOverrideDirectives();
        m_mergeEnabled = p_uploadParams.getMergeEnabled();
        m_excludeTypeNames = (Vector) p_uploadParams.getExcludedTypeNames();

        PageData result = getPageData();

        reset();
        CATEGORY.debug("getUploadReferencePageData() -- done");
        return result;
    }

    private PageData getPageData() throws GeneralException
    {
        CATEGORY.debug("getPageData()");
        // Create a new OPD which will receive the raw data from
        // TuvManager and CommentManager.
        m_offlinePage = new OfflinePageData();
        m_offlinePage.setPopulate100(populate100);
        m_segmentCounter = 0;

        if (isUploadRequest())
        {
            if (m_mergeOverrideDirectives != null)
            {
                m_hasMergeOverrideDirectives = true;
            }
        }
        else
        {
            m_offlinePage.setAnnotationThreshold(m_annotationThreshold);
        }

        // check parameters
        if (m_pageName == null || m_pageName.length() == 0
                || m_sourcePageIdAsLong == -1)
        {
            OfflinePageDataGeneratorException ex = new OfflinePageDataGeneratorException(
                    OfflinePageDataGeneratorException.MSG_FAILED_ARGS_GETDOWNLOADPAGE,
                    null, null);
            CATEGORY.error(ex.getMessage(), ex);
            throw ex;
        }

        // get all the items from the database that are needed to build a
        // PageData
        getDbData();

        // set issues
        m_offlinePage.setIssues(m_issues);

        // Get Add/Delete info (used to filter deleted segments)
        CATEGORY.debug("getting extracted source file");
        m_pageHasGsTags = getExtractedSourceFile(m_srcPage).containGsTags();
        if (m_addDeleteEnabled && m_pageHasGsTags)
        {
            getInterpretedTuIds();
        }

        // Begin --
        // Migration of raw TuvManager Data to OfflineEditManager.
        // Later, the raw data will be converted to presentation data
        // by further processing outside of this class.

        // Add all unmerged parents and subs for use as references and
        // resources.
        CATEGORY.debug("adding unmerged segments");
        addUnMergedSegments();

        // Add all segments according to their merge state.
        // Unmerged segments are mapped to the same resource added by
        // addUnMergedSegments(). Merged segments get newly added.
        // For this reason addMergedSegments() must be called after
        // addUnMergedSegments().
        CATEGORY.debug("adding merged segments");
        addMergedSegments();

        // End - migration of raw TuvManager Data to OfflineEditManager

        // Now free m_ref_pageSegs if the request came from download.
        // We only need to hang on to PageSegments if the request came
        // from upload.
        // TODO: make this OfflinePageDataGenerator a common class
        // (i.e. to not need downloadParam object)
        if (isDownloadRequest())
        {
            m_ref_pageSegs = null;
        }

        // Create a PageData object and return it.
        CATEGORY.debug("creating page data object");
        PageData result = new PageData(m_ref_pageSegs, m_offlinePage);
        CATEGORY.debug("done with getPageData()");
        result.setMatchStatistics(m_matchTypeStats);
        return result;
    }

    /**
     * Adds all parent and subflows as separate unmerged segments.
     */
    private void addUnMergedSegments()
            throws OfflinePageDataGeneratorException,
            OfflineEditorManagerException, PageSegmentsException
    {
        Iterator pairsIt = m_ref_pageSegs
                .getUnmergedSegmentPairIterator(m_targetLocale);
        while (pairsIt.hasNext())
        {
            // Get the next set of source/target Tuvs
            SegmentPair pair = (SegmentPair) pairsIt.next();

            OfflineSegmentData osd = makeParent(pair);
            if (osd != null)
            {
                m_offlinePage.addUnmergedSegmentResource(osd);
                m_offlinePage.addUnmergedSegmentResource(makeSubs(pair, false));
            }
        }
    }

    /**
     * Add merged parents and subflows as separate segments. NOTE: This method
     * must be called after addUnMergedSegments() !!!!
     */
    private void addMergedSegments() throws OfflinePageDataGeneratorException,
            OfflineEditorManagerException, PageSegmentsException
    {
        OfflineSegmentData OSDParent = null;
        ArrayList OSDsubs = null;

        Iterator pairsIt = m_ref_pageSegs
                .getSegmentPairIterator(m_targetLocale);

        while (pairsIt.hasNext())
        {
            // Get the next set of source/target Tuvs
            SegmentPair pair = (SegmentPair) pairsIt.next();

            OSDParent = makeParent(pair);
            if (OSDParent == null)
            {
                continue;
            }

            OSDsubs = makeSubs(pair, true);

            if (pair.isMergedSegment())
            {
                m_offlinePage.addMergedSegmentResource(OSDParent);
                m_offlinePage.addMergedSegmentResource(OSDsubs);
            }

            // Maps the parent-target to either a merged or unmerged
            // reference resource. Unmerged resources should already
            // have been added. See getOfflineDownloadPage().
            if (m_offlinePage.mapSegmentToResource(OSDParent
                    .getDisplaySegmentID()) == false)
            {
                String args[] =
                { OSDParent.getDisplaySegmentID() };
                throw new OfflinePageDataGeneratorException(
                        OfflinePageDataGeneratorException.MSG_FAILED_TO_MAP_SEGID_TO_RES_DATA,
                        args, null);
            }

            // Map the sub-targets to either a merged or unmerged
            // reference resource. Unmerged resources should already
            // have been added. See getOfflineDownloadPage().
            for (Iterator subsIt = OSDsubs.iterator(); subsIt.hasNext();)
            {
                OfflineSegmentData sub = (OfflineSegmentData) subsIt.next();

                if (m_offlinePage.mapSegmentToResource(sub
                        .getDisplaySegmentID()) == false)
                {
                    String args[] =
                    { sub.getDisplaySegmentID() };
                    throw new OfflinePageDataGeneratorException(
                            OfflinePageDataGeneratorException.MSG_FAILED_TO_MAP_SEGID_TO_RES_DATA,
                            args, null);
                }
            }
        }
    }

    /**
     * Creates an OfflineSegmentData entry and appends it to the current
     * OfflinePageData segment list.
     * 
     * Note: excluded segments are **always** removed from the offline file
     * while protected exacts are **always** included. Therefore,
     * UploadPageSaver:initializeAndGetReferencePage() must do the same to keep
     * the segment counts in sync for error checking.
     * 
     * @param p_srcTuv
     *            the source Tuv
     * @param p_trgTuv
     *            the target Tuv
     */
    private OfflineSegmentData makeParent(SegmentPair p_pair)
            throws OfflinePageDataGeneratorException
    {
        long jobId = m_srcPage.getJobId();

        Tuv srcTuv = p_pair.getSourceTuv();
        Tuv trgTuv = p_pair.getTargetTuv();

        ArrayList fmList = null;
        ArrayList fmRefTmsList = null;
        boolean parentProtection = false;
        String trgGxml = "";
        float trgScore = SCORE_UNKNOWN;
        String matchTypeDisplay = "";
        int matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_UNDEFINED;
        boolean fuzzyMatchInserted = false;
        String itemType = srcTuv.getTu(jobId).getTuType();
        int state = -1;

        // We now remove excluded item from download.
        if (isExcluded(srcTuv.getGxmlElement(), itemType))
        {
            return null;
        }

        // Not an excluded item, process normally.
        if (isDownloadRequest())
        {
            fmList = getTMDataForSegment(p_pair, "0");
            fmRefTmsList = getTMDataRefTmsForSegment(p_pair, "0");
            state = m_matchTypeStats.getLingManagerMatchType(srcTuv.getId(),
                    "0");
        }

        List isProtectedChangeable = new ArrayList();

        // First, determine which gxml to use as the target and the
        // score indicator.
        if (state == LeverageMatchLingManager.EXACT)
        {
            // NOTE: The check above determines whether the parent is
            // an exact match type that has been leveraged on import
            // (copied).
            trgGxml = trgTuv.getGxmlExcludeTopTags();
            trgScore = 100;

            if (isDownloadRequest())
            {
                parentProtection = determineTuvDownloadLockStatus(trgTuv,
                        isProtectedChangeable);
            }

            if (parentProtection
                    && TMEditType == AmbassadorDwUpConstants.TM_EDIT_TYPE_100)
                parentProtection = false;

            matchTypeDisplay = getDisplayMatchType(INDICATE_EXACT,
                    parentProtection, String.valueOf(trgScore));
            matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_EXACT;
        }
        else if (state == LeverageMatchLingManager.UNVERIFIED)
        {
            // NOTE: The check above determines whether the parent is
            // an exact match type that has been leveraged on import
            // (copied).
            trgGxml = trgTuv.getGxmlExcludeTopTags();
            trgScore = 100;

            // always editable
            // if(isDownloadRequest())
            // {
            // parentProtection = determineTuvDownloadLockStatus(trgTuv);
            // }

            matchTypeDisplay = getDisplayMatchType(INDICATE_UNVERIFIED_EXACT,
                    parentProtection, String.valueOf(trgScore));
            matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_UNVERIFIED_EXACT;
        }
        else if (trgTuv.isNotLocalized() && isDownloadRequest()
                && isDownloadForTrados())
        {
            // This segment has not been touched by a human and we are
            // downloading for Trados. Insert the first fuzzy and its
            // score - if available.
            String topGxml = getTopLeveragedMatchGxml(fmList, srcTuv, trgTuv, 0);

            if (topGxml != null)
            {
                trgGxml = topGxml;
                fuzzyMatchInserted = true;
                trgScore = getTopLeveragedMatchScore(fmList);
                // parentProtection == default
                matchTypeDisplay = getDisplayMatchType(INDICATE_FUZZY_TRADOS,
                        parentProtection, String.valueOf(trgScore));
                matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_FUZZY;
            }
            else
            {
                // No fuzzies are available for Trados, use the
                // current target
                trgGxml = trgTuv.getGxmlExcludeTopTags();
                trgScore = 0; // no fuzzy
                // parentProtection == default
                matchTypeDisplay = getDisplayMatchType(INDICATE_NO_MATCH,
                        parentProtection, String.valueOf(trgScore));
                matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_NOMATCH;
            }
        }
        else if (trgTuv.isNotLocalized())
        {
            // This segment has not been touched by a human
            // (NOT_LOCALIZED) and we are downloading for TEXT or RTF.
            // Use the current target text and include the top fuzzy
            // SCORE ( if available ). If a match is available, the
            // match type label will tell the user to look in the
            // resource pages to see the fuzzy matches.
            String topGxml = getTopLeveragedMatchGxml(fmList, srcTuv, trgTuv, 0);

            if (topGxml != null)
            {
                trgGxml = trgTuv.getGxmlExcludeTopTags();
                trgScore = getTopLeveragedMatchScore(fmList);
                // parentProtection == default
                matchTypeDisplay = getDisplayMatchType(INDICATE_FUZZY_NORMAL,
                        parentProtection, String.valueOf(trgScore));
                matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_FUZZY;
            }
            else
            {
                // No fuzzy matches are found, we again use the
                // current target text but this time the match type is
                // a no match.
                trgGxml = trgTuv.getGxmlExcludeTopTags();
                trgScore = 0; // no fuzzy
                // parentProtection == default
                matchTypeDisplay = getDisplayMatchType(INDICATE_NO_MATCH,
                        parentProtection, String.valueOf(trgScore));
                matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_NOMATCH;
            }
        }
        else
        // When a segment **is** Localized
        {
            // we **always** use the current target.
            trgGxml = trgTuv.getGxmlExcludeTopTags();
            trgScore = 100; // must be set for Trados output

            // This segment has been touched by a human but we want to
            // indicate to the user that it originally had a TM match.
            String topGxml = getTopLeveragedMatchGxml(fmList, srcTuv, trgTuv, 0);
            float topScore = getTopLeveragedMatchScore(fmList);

            // if this tuv is not exact, and it has sub segment with exact
            // match,
            // set it score to really fuzzy score
            TuvState tuvState = trgTuv.getState();
            if (topScore < 100
                    && tuvState.equals(TuvState.EXACT_MATCH_LOCALIZED)
                    && srcTuv.getSubflowsAsGxmlElements() != null
                    && srcTuv.getSubflowsAsGxmlElements().size() > 0)
            {
                trgScore = (topScore == SCORE_UNKNOWN) ? 0 : topScore;
            }

            if (topGxml == null)
            {
                // there was no previous or current match
                matchTypeDisplay = getDisplayMatchType(INDICATE_CURRENT_TARGET,
                        parentProtection, String.valueOf(trgScore));
                matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_NOMATCH;
            }
            else
            {
                if (topScore >= 100)
                {
                    // there was a previous or current exact match
                    parentProtection = determineTuvDownloadLockStatus(trgTuv,
                            isProtectedChangeable);
                    matchTypeDisplay = getDisplayMatchType(INDICATE_EXACT,
                            parentProtection, String.valueOf(topScore));
                    matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_EXACT;
                }
                else
                {
                    // there was a previous or current fuzzy match
                    matchTypeDisplay = getDisplayMatchType(
                            INDICATE_FUZZY_NORMAL, parentProtection,
                            String.valueOf(topScore));
                    matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_FUZZY;
                    // If populate 100, the "trgGxml" should be translated
                    // content and "trgScore" should be 100 always.
                    if (populate100 && trgScore == 100)
                    {
                        // do nothing.
                    }
                    else if (populateFuzzy)
                    {
                        trgGxml = topGxml;
                        trgScore = topScore;
                    }
                    else
                    {
                        trgScore = topScore;
                    }
                }
            }
        }

        String srgGxml = srcTuv.getGxmlExcludeTopTags();
        if ((InternalTextUtil.isInternalText(srgGxml) && !trgTuv.isLocalized())
                || isPopulateSrcAsTrg(trgScore))
        {
            if (isDownloadForOmegaT() && MTHelper.isMTTaggedSegment(trgGxml))
            {
                // GBS-3722, just use MT tagged target segment, do not use
                // source
            }
            else
            {
                trgGxml = srgGxml;
            }
        }

        if (m_pageName.endsWith(".idml"))
        {
            srgGxml = IdmlHelper.formatForOfflineDownload(srgGxml);
            trgGxml = IdmlHelper.formatForOfflineDownload(trgGxml);
        }

        // Then create/append offline parent seg
        OfflineSegmentData result = new OfflineSegmentData(
                String.valueOf(trgTuv.getTu(jobId).getTuId()),
                srcTuv.getDataType(jobId), itemType, srgGxml, trgGxml,
                trgScore, matchTypeDisplay, matchTypeId, fmList, fmRefTmsList,
                parentProtection, getTermDataForSegment(p_pair));

        result.setTargetTuv(trgTuv);
        result.setSourceTuv(srcTuv);

        // result.setCopyOfSource((trgTuv.isNotLocalized() &&
        // !fuzzyMatchInserted));

        result.setCopyOfSource(trgTuv.isNotLocalized()
                && (state != LeverageMatchLingManager.UNVERIFIED)
                && (state != LeverageMatchLingManager.EXACT)
                && !fuzzyMatchInserted);
        result.setIsStartOfNewPara(isStartOfNewPara(trgTuv, jobId));
        result.setMergedIds((ArrayList) p_pair.getMergedTuIds());
        result.setTouched(trgTuv);
        result.setTrgTuvId(trgTuv.getIdAsLong());
        result.setBackReference(m_offlinePage);
        if (isProtectedChangeable != null && isProtectedChangeable.size() > 0)
        {
            result.setProtectedChangeable(false);
        }

        if (m_srcPage != null)
        {
            result.setDisplayPageName(m_srcPage.getDisplayPageName());
            result.setPageId(m_srcPage.getId());
        }

        return result;
    }

    /**
     * Creates multiple OfflineSegmentData entries (one per sub) and appends
     * them to the current OfflinePageData segment list. an exception is thrown
     * if there are not the same number of subflows in both the source and the
     * target.
     * 
     * Note: All sub segments (including protected and exclude-protected ones)
     * are downloaded for added context.
     * 
     * Note that in the offline context, the only difference between a parent
     * and a sub is the offline segmentID.
     * 
     * Protection is inherited from the parent.
     * 
     * Excluded segments appear as protected in the offline file.
     * 
     * @param p_pair
     *            the SegmentPair
     * @param p_isNormalPageSegs
     *            true means they reflect current merge state
     * @return a collection of OfflineSegmentData
     */
    private ArrayList makeSubs(SegmentPair p_pair, boolean p_isNormalPageSegs)
            throws OfflinePageDataGeneratorException
    {
        long jobId = m_srcPage.getJobId();

        ArrayList OSDsubs = new ArrayList();
        Tuv srcTuv = p_pair.getSourceTuv();
        Tuv trgTuv = p_pair.getTargetTuv();

        String trgSubGxml = "";
        float trgScore = SCORE_UNKNOWN;
        boolean fuzzyMatchInserted = false;
        boolean subProtection = false;
        String matchTypeDisplay = "";
        int matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_UNDEFINED;
        String itemType = srcTuv.getTu(jobId).getTuType();
        int state = -1;

        // Build subflow maps:
        // In order to get the ptag ID under which each sub appears,
        // we build maps the sub data using a list of parents elements
        // that contain the subs.
        List srcParentsOfSubs = srcTuv.getSubflowParentsAsGxmlElements();
        HashMap srcSubflowMap = makeSrcSubflowDataMap(p_pair, jobId);
        List trgParentsOfSubs = trgTuv.getSubflowParentsAsGxmlElements();
        HashMap trgSubflowMap = makeTrgSubflowDataMap(p_pair, jobId);

        // the source order drives sub-segment creation
        ListIterator it1 = srcParentsOfSubs.listIterator();
        while (it1.hasNext())
        {
            // get a single source parent-of-subs
            GxmlElement aSrcParentOfSubs = (GxmlElement) it1.next();
            List srcSubs = aSrcParentOfSubs
                    .getDescendantElements(GxmlElement.SUB_TYPE);

            ListIterator it2 = srcSubs.listIterator();
            while (it2.hasNext())
            {
                GxmlElement srcSub = (GxmlElement) it2.next();
                String srcSubId = srcSub.getAttribute(GxmlNames.SUB_ID);
                ArrayList fmList = null;
                ArrayList fmRefTmsList = null;
                SubflowData trgSubData = (SubflowData) trgSubflowMap
                        .get(srcSubId);

                if (isDownloadRequest())
                {
                    fmList = getTMDataForSegment(p_pair, srcSubId);
                    fmRefTmsList = getTMDataRefTmsForSegment(p_pair, srcSubId);
                }

                if (trgSubData == null && p_isNormalPageSegs)
                {
                    // TODO no longer takes two params
                    String[] args =
                    { srcSubId, "" };
                    OfflinePageDataGeneratorException ex = new OfflinePageDataGeneratorException(
                            OfflinePageDataGeneratorException.MSG_FAILED_TO_GET_SUBFLOW_ID,
                            args, null);
                    CATEGORY.error(ex.getMessage(), ex);
                    throw ex;
                }
                else if (trgSubData == null)
                {
                    // The target may be empty in the case that we are
                    // working with a merged segment. The second,
                    // third, fourth (or greater) targets in a merge
                    // will be empty. If the target sub not present
                    // (due to mergers) use the source to build a
                    // resource segment
                    trgSubData = (SubflowData) srcSubflowMap.get(srcSubId);
                }

                String subId = trgSubData.getDownloadSubId();
                GxmlElement trgSub = trgSubData.getSub();
                String trgSubflowRootId = OfflineEditHelper
                        .makeSubSegIdPrefix(
                                trgSubData.getDownloadTuId(),
                                (m_fileFormatId == DOWNLOAD_FILE_FORMAT_RTF_PARAVIEW_ONE) ? null
                                        : trgSubData.getParentOfSubTagName(),
                                (m_fileFormatId == DOWNLOAD_FILE_FORMAT_RTF_PARAVIEW_ONE) ? BOOKMARK_SEG_ID_DELIM
                                        : SEGMENT_ID_DELIMITER);

                // - filter excluded items types "on the sub type itself"
                if (isExcluded(srcSub, itemType))
                {
                    // Note: the entire parent was excluded!!
                    return OSDsubs;
                    // We now remove excluded item from download
                }

                // Determine whether the PARENT is an exact match type
                // that has been leveraged on import (copied into target).
                if (isDownloadRequest())
                {
                    state = m_matchTypeStats.getLingManagerMatchType(
                            srcTuv.getId(), srcSubId);
                }

                if (state == LeverageMatchLingManager.EXACT)
                {
                    trgSubGxml = trgSub.toGxmlExcludeTopTags();

                    if (isDownloadRequest())
                    {
                        subProtection = determineSubDownloadLockStatus(srcTuv,
                                srcSubId);
                    }

                    // Subflows are included in the comparison when we
                    // find an exact match, so the subflow score is
                    // 100 also.
                    trgScore = 100;

                    matchTypeDisplay = getDisplayMatchType(INDICATE_EXACT_SUB,
                            subProtection, String.valueOf(trgScore));
                    matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_EXACT;
                }
                else if (state == LeverageMatchLingManager.UNVERIFIED)
                {
                    trgSubGxml = trgSub.toGxmlExcludeTopTags();

                    // Unverified is always editable
                    // if (isDownloadRequest())
                    // {
                    // subProtection = determineSubDownloadLockStatus(srcTuv,
                    // srcSubId);
                    // }

                    // Subflows are included in the comparison when we
                    // find an exact match, so the subflow score is
                    // 100 also.
                    trgScore = 100;

                    matchTypeDisplay = getDisplayMatchType(
                            INDICATE_UNVERIFIED_EXACT_SUB, subProtection,
                            String.valueOf(trgScore));
                    matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_UNVERIFIED_EXACT;
                }
                else if (state == LeverageMatchLingManager.FUZZY
                        || state == LeverageMatchLingManager.STATISTICS)
                {
                    if (isDownloadForTrados())
                    {
                        // Assuming sub segment has not been touched
                        // by a human (NOT_LOCALIZED) and we are
                        // downloading for Trados. Use the first
                        // fuzzy and its score - if available.
                        String topGxml = getTopLeveragedMatchGxml(fmList,
                                srcTuv, trgTuv, Integer.parseInt(srcSubId));

                        if (topGxml != null)
                        {
                            trgSubGxml = topGxml;
                            fuzzyMatchInserted = true;
                            trgScore = getTopLeveragedMatchScore(fmList);
                            matchTypeDisplay = getDisplayMatchType(
                                    INDICATE_FUZZY_TRADOS, subProtection,
                                    String.valueOf(trgScore));
                            matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_FUZZY;
                        }
                        else
                        {
                            trgSubGxml = trgSub.toGxmlExcludeTopTags();
                            trgScore = SCORE_UNKNOWN;
                            matchTypeDisplay = getDisplayMatchType(
                                    INDICATE_NO_MATCH, subProtection,
                                    String.valueOf(trgScore));
                            matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_NOMATCH;
                        }
                    }
                    else
                    {
                        // This sub has not been touched by a human
                        // (NOT_LOCALIZED) and we are downloading for
                        // TEXT or RTF. Use the current target sub
                        // and include the top fuzzy SCORE (if
                        // available). If a match is available, the
                        // match type label will tell the user to look
                        // in the resource pages to see the fuzzy
                        // matches.
                        String topGxml = getTopLeveragedMatchGxml(fmList,
                                srcTuv, trgTuv, Integer.parseInt(srcSubId));

                        if (topGxml != null)
                        {
                            trgSubGxml = trgSub.toGxmlExcludeTopTags();
                            trgScore = getTopLeveragedMatchScore(fmList);
                            matchTypeDisplay = getDisplayMatchType(
                                    INDICATE_FUZZY_NORMAL, subProtection,
                                    String.valueOf(trgScore));
                            matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_FUZZY;
                        }
                        else
                        {
                            trgSubGxml = trgSub.toGxmlExcludeTopTags();
                            trgScore = 0;
                            matchTypeDisplay = getDisplayMatchType(
                                    INDICATE_NO_MATCH, subProtection,
                                    String.valueOf(trgScore));
                            matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_NOMATCH;
                        }
                    }
                }
                else
                // default
                {
                    // We **always** use the current target.
                    trgSubGxml = trgSub.toGxmlExcludeTopTags();
                    trgScore = 0; // this affects Trados output
                    matchTypeDisplay = getDisplayMatchType(
                            INDICATE_CURRENT_TARGET_SUB, subProtection,
                            String.valueOf(trgScore));
                    matchTypeId = AmbassadorDwUpConstants.MATCH_TYPE_NOMATCH;
                }

                // *Always* use the SUB's source datatype if sub
                // datatype is not present - we get it from the parent
                String srcDataType = srcSub
                        .getAttribute(GxmlNames.SUB_DATATYPE);
                if (srcDataType == null || srcDataType.length() == 0)
                {
                    srcDataType = srcTuv.getDataType(jobId);
                }

                String srcItemType = srcSub.getAttribute(GxmlNames.SUB_TYPE);
                if (srcItemType == null || srcItemType.length() == 0)
                {
                    srcItemType = "text";
                }

                if (isPopulateSrcAsTrg(trgScore))
                {
                    trgSubGxml = srcSub.toGxmlExcludeTopTags();
                }

                // - create/append offline subflow
                OfflineSegmentData result = new OfflineSegmentData(
                        trgSubflowRootId + subId,
                        // always refer to source datatype
                        srcDataType, srcItemType,
                        srcSub.toGxmlExcludeTopTags(), trgSubGxml, trgScore,
                        matchTypeDisplay, matchTypeId, fmList, fmRefTmsList,
                        subProtection, null);

                result.setCopyOfSource((state != LeverageMatchLingManager.UNVERIFIED)
                        && (state != LeverageMatchLingManager.EXACT)
                        && !fuzzyMatchInserted);
                result.setSourceTuv(srcTuv);
                result.setDisplayParentOfSubTagName(trgSubData
                        .getParentOfSubTagName());
                result.setTouched(trgTuv);
                result.setTrgTuvId(trgTuv.getIdAsLong());
                result.setBackReference(m_offlinePage);
                result.setSourceTuv(srcTuv);
                result.setTargetTuv(trgTuv);

                if (m_srcPage != null)
                {
                    result.setDisplayPageName(m_srcPage.getDisplayPageName());
                    result.setPageId(m_srcPage.getId());
                }

                OSDsubs.add(result);
            }
        }

        return OSDsubs;
    }

    /**
     * Gets all the required data to build an Offline page from the DB.
     */
    private void getDbData() throws OfflinePageDataGeneratorException,
            OfflineEditorManagerException
    {
        CATEGORY.debug("getDbData()");
        long startTime = System.currentTimeMillis();

        // Get source page
        m_srcPage = getSourcePage(m_sourcePageIdAsLong);

        if (m_srcPage == null)
        {
            String[] args =
            { String.valueOf(m_sourcePageIdAsLong) };
            OfflinePageDataGeneratorException ex = new OfflinePageDataGeneratorException(
                    OfflinePageDataGeneratorException.MSG_SOURCE_PAGE_NOT_FOUND,
                    args, null);
            CATEGORY.error(ex.getMessage(), ex);
            throw ex;
        }

        // Get raw tuv data:
        m_ref_pageSegs = OfflineEditHelper.getPageSegments(m_srcPage,
                m_targetLocale, m_mergeOverrideDirectives, isUploadRequest(),
                m_mergeEnabled);

        if (isDownloadRequest())
        {
            // get ALL fuzzy matches for all source TuvIds
            // (keyed by source tuvId)
            getTMDataForPage(m_srcPage.getIdAsLong(), m_targetLocale);

            if (m_fuzzyMatchMap == null)
            {
                OfflinePageDataGeneratorException ex = new OfflinePageDataGeneratorException(
                        OfflinePageDataGeneratorException.MSG_FAILED_TO_GET_LEVERAGE_MAP,
                        null, null);
                CATEGORY.error(ex.getMessage(), ex);
                throw ex;
            }

            // get terminology matches for all source TuvIds
            m_termResultSet = getTermDataForPage(m_targetLocale);

            // get all issues for all trg Tuvs
            m_issues = getIssueDataForPage(m_trgPage.getIdAsLong());
        }
        else
        {
            // On upload of issue-enabled formats, the target page ID
            // is passed in so we can get its issues.
            m_issues = getIssueDataForPage(m_targetPageIdAsLong);
        }

        long endTime = System.currentTimeMillis();
        Long duration = new Long(endTime - startTime);
    }

    /**
     * Gets interpreted TU ids (meaning, the TU ids after interpreting GS
     * add/delete tags). The set is later used to filter out deleted Tuvs.
     */
    private void getInterpretedTuIds() throws OfflinePageDataGeneratorException
    {
        try
        {
            // Assumes this source page has an extracted file.
            // Shouldn't have reached this method if it doesn't.
            PageTemplate srcPageTemplate = getExtractedSourceFile(m_srcPage)
                    .getPageTemplate(PageTemplate.TYPE_OFFLINE);

            Collection tp = ServerProxy.getPageManager()
                    .getTemplatePartsForSourcePage(m_srcPage.getIdAsLong(),
                            srcPageTemplate.getTypeAsString());

            // ALWAYS set the template parts before getting the page data.
            srcPageTemplate.setTemplateParts(new ArrayList(tp));

            SnippetPageTemplate template = new SnippetPageTemplate(
                    srcPageTemplate, m_targetLocale.toString());

            m_interpretedTuIds = template.getInterpretedTuIds();
        }
        catch (Exception ex)
        {
            String[] args =
            { String.valueOf(m_srcPage.getId()), m_targetLocale.toString() };
            OfflinePageDataGeneratorException ex1 = new OfflinePageDataGeneratorException(
                    OfflinePageDataGeneratorException.MSG_FAILED_TO_GET_INTERPRETED_TUIDS,
                    args, ex);
            CATEGORY.error(ex1.getMessage(), ex1);
            throw ex1;
        }
    }

    /**
     * Sets the header information for the current page.
     */
    private void setHeaderValues(OfflinePageData p_opd,
            DownloadParams p_downloadParams)
            throws OfflinePageDataGeneratorException
    {
        p_opd.setDocumentFormat(getExtractedSourceFile(m_srcPage).getDataType());

        // Pages are generated with GXML segment content.
        // The downloadApi handles conversion to desired ptag format.
        p_opd.setPlaceholderFormat(AmbassadorDwUpConstants.TAG_TYPE_GXML);

        p_opd.setWorkflowId(p_downloadParams.getWorkflowID());
        p_opd.setTaskId(p_downloadParams.getTaskID());
        p_opd.setPageId(m_sourcePageIdAsString);
        p_opd.setCanUseUrl(m_canUseUrl);
        p_opd.setPageName(m_pageName);
        p_opd.setPageUrlPrefix(p_downloadParams.getUrlPrefix());
        // p_opd.setDownloadEditAll(p_downloadParams.getDownloadEditAllState());

        p_opd.setSourceLocaleName(p_downloadParams.getSourceLocale().toString());
        p_opd.setTargetLocaleName(p_downloadParams.getTargetLocale().toString());

        // Get the IANA encoding name (for display in the file header).
        String ianaEncoding = CodesetMapper.getIanaCharset(p_downloadParams
                .getEncoding());

        if (ianaEncoding == null)
        {
            String[] args =
            { p_downloadParams.getEncoding() };
            OfflinePageDataGeneratorException ex = new OfflinePageDataGeneratorException(
                    OfflinePageDataGeneratorException.MSG_UNKNOWN_ENCODING,
                    args, null);
            CATEGORY.error(ex.getMessage(), ex);
            throw ex;
        }

        p_opd.setEncoding(ianaEncoding);

        // get/set word counts
        PageWordCounts wrdCnts = getTargetPageWordCounts(m_sourcePageIdAsLong,
                p_downloadParams.getTargetLocale().getId());

        p_opd.setExactMatchWordCount((wrdCnts == null) ? -1 : wrdCnts
                .getInContextWordCount() + wrdCnts.getSegmentTmWordCount());

        p_opd.setFuzzyMatchWordCount((wrdCnts == null) ? -1 : wrdCnts
                .getLowFuzzyWordCount()
                + wrdCnts.getMedFuzzyWordCount()
                + wrdCnts.getMedHiFuzzyWordCount()
                + wrdCnts.getHiFuzzyWordCount());

        p_opd.setNoMatchWordCount((wrdCnts == null) ? -1 : wrdCnts
                .getNoMatchWordCount());

        p_opd.setTMEditType(p_downloadParams.getTMEditType());
    }

    /**
     * Wraps the code for getting the source page from the DB and handling any
     * exceptions.
     * 
     * @param p_srourcePageId
     *            the id of the source page you are requesting
     * @return the actual source page
     */
    private SourcePage getSourcePage(long p_sourcePageId)
            throws OfflinePageDataGeneratorException
    {
        PageManager mgr = null;

        try
        {
            mgr = ServerProxy.getPageManager();
            return mgr.getSourcePage(p_sourcePageId);
        }
        catch (Exception ex)
        {
            CATEGORY.error(ex.getMessage(), ex);
            throw new OfflinePageDataGeneratorException(ex);
        }
    }

    /**
     * Wraps the code for getting the target page word counts from the DB and
     * handling any exceptions.
     * 
     * Note: Currently, the only reason we need the target page is to get the
     * word counts. Upload/download otherwise uses TuvManager, the source page
     * Id and the source and target locales to get the job done.
     * 
     * @param p_sourcePageId
     *            the id of the source page you are requesting the target page
     *            for.
     * @param p_targetLocaleId
     *            the locale of the target page
     * @return the target page word counts object
     */
    private PageWordCounts getTargetPageWordCounts(long p_sourcePageId,
            long p_targetLocaleId) throws OfflinePageDataGeneratorException
    {
        try
        {
            PageManager mgr = ServerProxy.getPageManager();
            TargetPage trgPage = mgr.getTargetPage(p_sourcePageId,
                    p_targetLocaleId);

            return trgPage != null ? trgPage.getWordCount() : null;
        }
        catch (Exception ex)
        {
            CATEGORY.error(ex.getMessage(), ex);
            throw new OfflinePageDataGeneratorException(ex);
        }
    }

    /**
     * Wraps the code for getting the fuzzy matches and match type statistics
     * and handling any exceptions.
     * 
     * @param p_sourcePageId
     *            the source page id for which you want the matches
     * @param p_targetLocale
     *            the locale you want the matches for
     */
    private void getTMDataForPage(Long p_sourcePageId,
            GlobalSightLocale p_targetLocale)
            throws OfflinePageDataGeneratorException
    {
        try
        {
            SourcePage sp = ServerProxy.getPageManager().getSourcePage(
                    p_sourcePageId);
            List leverageMatches = LingServerProxy
                    .getLeverageMatchLingManager()
                    .getLeverageMatchesForOfflineDownLoad(p_sourcePageId,
                            p_targetLocale.getIdAsLong());
            if (leverageMatches != null)
            {
                m_fuzzyMatchMap = getLeverageMatchMap(leverageMatches);
                // GBS-3776
                Job job = ServerProxy.getJobHandler().getJobById(sp.getJobId());
                int threshold = 0;
                if (job != null)
                {
                	threshold = job.getLeverageMatchThreshold();
                    TranslationMemoryProfile tmp = job.getL10nProfile()
                            .getTranslationMemoryProfile();
                    String refTms = tmp.getRefTMsToLeverageFrom();
                    if (!StringUtil.isEmpty(refTms))
                    {
                        List<Long> refTmIdsForPenalty = new ArrayList<Long>();
                        String[] ids = refTms.split(",");
                        for (String id : ids)
                        {
                            try
                            {
                                refTmIdsForPenalty.add(Long.parseLong(id));
                            }
                            catch (Exception ignore)
                            {
                            }
                        }
                        m_fuzzyMatchRefTmsMap = getLeverageMatchMap(
                                leverageMatches, refTmIdsForPenalty);
                    }
                }
                m_matchTypeStats = getMatchTypesForStatistics(leverageMatches,
                		threshold, sp.getJobId());
            }
        }
        catch (Exception ex)
        {
            CATEGORY.error(ex.getMessage(), ex);
            throw new OfflinePageDataGeneratorException(ex);
        }
    }

    private MatchTypeStatistics getMatchTypesForStatistics(
            List p_leverageMatches, int p_levMatchThreshold, long p_jobId)
    {
    	// TODO: should this keep same as "LeverageMatchLingManagerLocal.getMatchTypesForStatistics(..)"?
        Map<String, LeverageMatch> leverageMatchesMap = new HashMap<String, LeverageMatch>();
        // remove lower score_num record
        for (Iterator it = p_leverageMatches.iterator(); it.hasNext();)
        {
            LeverageMatch match = (LeverageMatch) it.next();
            LeverageMatch cloneMatch = new LeverageMatch(match);
            long originalSourceTuvId = cloneMatch.getOriginalSourceTuvId();

            float scoreNum = cloneMatch.getScoreNum();
            String subId = cloneMatch.getSubId();
            String idKey = MatchTypeStatistics.makeKey(originalSourceTuvId,
                    subId);
            LeverageMatch lm = (LeverageMatch) leverageMatchesMap.get(idKey);
            if (lm != null)
            {
                if (scoreNum == 100)
                {
                    if ((LeverageUtil.compareSid(lm, cloneMatch, p_jobId) > 0 && cloneMatch
                            .getOrderNum() != -1)
                            || lm.getScoreNum() < scoreNum)
                    {
                        leverageMatchesMap.remove(idKey);
                        leverageMatchesMap.put(idKey, cloneMatch);
                    }
                }
                else if (lm.getScoreNum() < scoreNum)
                {
                    leverageMatchesMap.remove(idKey);
                    leverageMatchesMap.put(idKey, cloneMatch);
                }
            }
            else
            {
                leverageMatchesMap.put(idKey, cloneMatch);
            }
        }

        MatchTypeStatistics result = new MatchTypeStatistics(p_levMatchThreshold);
        // set the match type with the found leverage matches
        Collection leverageMatches2 = leverageMatchesMap.values();
        List<String> list = new ArrayList<String>();
        for (Iterator it = leverageMatches2.iterator(); it.hasNext();)
        {
            LeverageMatch match = (LeverageMatch) it.next();
            String key = MatchTypeStatistics.makeKey(
                    match.getOriginalSourceTuvId(), match.getSubId());
            if (!list.contains(key))
            {
                result.addMatchType(match);
                list.add(key);
            }
        }

        return result;
    }

    private Map<Long, ArrayList<LeverageMatch>> getLeverageMatchMap(
            List p_leverageMatches, List<Long> refTmIdsForPenalty)
    {
        // Put all the LeverageMatch in HashMap grouping by original Tuv id
        Map<Long, ArrayList<LeverageMatch>> result = new HashMap<Long, ArrayList<LeverageMatch>>();

        for (Iterator it = p_leverageMatches.iterator(); it.hasNext();)
        {
            LeverageMatch match = (LeverageMatch) it.next();
            if (!refTmIdsForPenalty.contains(match.getTmId()))
            {
                continue;
            }

            Long key = new Long(match.getOriginalSourceTuvId());
            ArrayList<LeverageMatch> set = (ArrayList<LeverageMatch>) result
                    .get(key);

            if (set == null)
            {
                set = new ArrayList<LeverageMatch>();
                result.put(key, set);
            }

            // TreeSet sorts the elements
            set.add(match);
        }
        return result;
    }

    private Map<Long, ArrayList<LeverageMatch>> getLeverageMatchMap(
            List p_leverageMatches)
    {
        // Put all the LeverageMatch in HashMap grouping by original Tuv id
        Map<Long, ArrayList<LeverageMatch>> result = new HashMap<Long, ArrayList<LeverageMatch>>();

        for (Iterator it = p_leverageMatches.iterator(); it.hasNext();)
        {
            LeverageMatch match = (LeverageMatch) it.next();

            Long key = new Long(match.getOriginalSourceTuvId());
            ArrayList<LeverageMatch> set = (ArrayList<LeverageMatch>) result
                    .get(key);

            if (set == null)
            {
                set = new ArrayList<LeverageMatch>();
                result.put(key, set);
            }

            // TreeSet sorts the elements
            set.add(match);
        }
        return result;
    }

    /**
     * Wraps the code for getting the term matches and handling any exceptions.
     * 
     * @param p_sourceTuvIds
     *            a list of source TuvIds for which you want the matches
     * @param p_targetLocale
     *            the locale you want the matches in
     * @return Map of best matches keyed by source TuvIds
     */
    private TermLeverageMatchResultSet getTermDataForPage(
            GlobalSightLocale p_targetLocale)
            throws OfflinePageDataGeneratorException
    {
        TermLeverageManager mgr;

        try
        {
            mgr = ServerProxy.getTermLeverageManager();
            return mgr.getTermMatchesForPage(m_srcPage, p_targetLocale);
        }
        catch (Exception ex)
        {
            CATEGORY.error(ex.getMessage(), ex);
            throw new OfflinePageDataGeneratorException(ex);
        }
    }

    /**
     * Wraps the code for getting the page issues and handling any exceptions.
     * 
     * @param p_sourceTuvIds
     *            a list of source TuvIds for which you want the matches
     * @param p_targetLocale
     *            the locale you want the matches in
     * @return Map of best matches keyed by source TuvIds
     */
    private ArrayList<IssueImpl> getIssueDataForPage(Long p_trgPageId)
            throws OfflinePageDataGeneratorException
    {
        CommentManager mgr;

        try
        {
            mgr = ServerProxy.getCommentManager();
            return mgr.getIssues(Issue.TYPE_SEGMENT, p_trgPageId);
        }
        catch (Exception ex)
        {
            CATEGORY.error(ex.getMessage(), ex);
            throw new OfflinePageDataGeneratorException(ex);
        }
    }

    /**
     * Wraps the code for getting the gxml string from a LeverageMatch and
     * handling any exceptions.
     * 
     * @return the gxml for this match
     */
    private String getTopLeveragedMatchGxml(ArrayList p_fuzzyList,
            Tuv p_srcTuv, Tuv p_trgTuv, int p_subId)
            throws OfflinePageDataGeneratorException
    {
        if (p_fuzzyList == null || p_fuzzyList.size() == 0)
        {
            return null;
        }

        // Get what "used to be" the top level match before subs
        // leveraging was added.
        //
        // TODO: need to find top match at least one that is 100%
        // before TM changed, this was guaranteed (by jimH's code)
        LeverageMatch p_levMatch = (LeverageMatch) p_fuzzyList.get(0);

        try
        {
            return p_levMatch.getLeveragedTargetString();
        }
        catch (Exception ex)
        {
            throw new OfflinePageDataGeneratorException(ex);
        }
    }

    /**
     * Wraps the code for getting the score from a LeverageMatch and handling
     * any exceptions.
     * 
     * @return the score for this match
     */
    private float getTopLeveragedMatchScore(ArrayList p_fuzzyList)
            throws OfflinePageDataGeneratorException
    {
        if (p_fuzzyList == null || p_fuzzyList.size() == 0)
        {
            return SCORE_UNKNOWN;
        }

        LeverageMatch p_levMatch = (LeverageMatch) p_fuzzyList.get(0);

        if (p_levMatch == null)
        {
            return SCORE_UNKNOWN;
        }

        return p_levMatch.getScoreNum();
    }

    /**
     * Determines lock protection based on the state of the download edit all
     * button and the state of the tuv in question.
     * 
     * @param p_tuv
     *            the tuv in question.
     * @return true if protected, false if not.
     */
    private boolean determineTuvDownloadLockStatus(Tuv p_tuv, List isChangeable)
    {
        if (TMEditType == AmbassadorDwUpConstants.TM_EDIT_TYPE_BOTH)
        {
            // User has been granted permision and has selected to
            // unprotect all segments.
            return false;
        }

        // Else check the protection state of the tuv itself.
        long jobId = m_srcPage.getJobId();
        boolean result = EditHelper.isTuvInProtectedState(p_tuv, jobId);
        if (!result && p_tuv.getSubflowsAsGxmlElements() != null
                && p_tuv.getSubflowsAsGxmlElements().size() > 0)
        {
            Tuv srcTuv = p_tuv.getTu(jobId).getTuv(m_srcPage.getLocaleId(),
                    jobId);
            result = EditorHelper.isRealExactMatchLocalied(srcTuv, p_tuv,
                    m_matchTypeStats, "0", jobId);

            if (result)
            {
                // do not lock segment if it is MULTIPLE_TRANSLATION
                Types types = m_matchTypeStats.getTypes(srcTuv.getId(), "0");
                if (MatchState.MULTIPLE_TRANSLATION.equals(types
                        .getMatchState()))
                {
                    result = false;

                    if (isChangeable == null)
                    {
                        isChangeable = new ArrayList();
                    }
                    isChangeable.add("false");
                }
            }

        }

        return result;
    }

    /**
     * Determines lock protection based on the state of the download edit all
     * button and the state of the tuv/subflow in question.
     * 
     * Note: this is currently not used for both parent and sub. We are in
     * transition in merging how both editors (offline/online) get this
     * information.
     * 
     * @param p_srcTuv
     *            the parent tuv in question.
     * @param p_srcSubId
     *            the sub in question. To check the parent, enter 0 for sub id.
     * @return true if protected, false if not.
     */
    private boolean determineSubDownloadLockStatus(Tuv p_srcTuv, String p_subId)
    {
        if (TMEditType == AmbassadorDwUpConstants.TM_EDIT_TYPE_BOTH)
        {
            // User has been granted permision and has selected to
            // unprotect all segments.
            return false;
        }

        // Else check the protection state of the sub itself.
        if (m_matchTypeStats.getLingManagerMatchType(p_srcTuv.getId(), p_subId) == LeverageMatchLingManager.EXACT)
        {
            Types tps = m_matchTypeStats.getTypes(p_srcTuv.getId(), p_subId);

            // do not lock if have multiple translations
            if (MatchState.MULTIPLE_TRANSLATION.getCompareKey() == tps
                    .getMatchState().getCompareKey())
            {
                return false;
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    /**
     * Determines if a GxmlElement's itemtype is excluded.
     * 
     * @param p_element
     *            the element in question.
     * @param p_itemType
     *            the element's TU's item type
     * @return true if excluded, false if not.
     */
    private boolean isExcluded(GxmlElement p_element, String p_itemType)
            throws OfflinePageDataGeneratorException
    {
        return EditHelper.isTuvExcluded(p_element, p_itemType,
                m_excludeTypeNames);
    }

    /**
     * Gets the match type indicator string for display in the offline files.
     * The proper string is determined from the score + protection.
     * 
     * @param p_msgId
     *            the id of the root message to display
     * @param p_isProtected
     *            true indicates protection.
     * @param p_score
     *            the score used for a fuzzy match
     * @return the indicator display string
     */
    private String getDisplayMatchType(int p_msgId, boolean p_isProtected,
            String p_score)
    {
        String msg = "";
        boolean forTrados = false;

        switch (p_msgId)
        {
            case INDICATE_MATCH_TYPE_UNKNOWN:
                msg = m_resources
                        .getString(DisplayMatchTypeKeys.MSG_MATCHTYPE_UNKNOWN);
                break;
            case INDICATE_CURRENT_TARGET:
                // show nothing for current target
                msg = "";
                /*
                 * m_resources.getString( ?
                 * DisplayMatchTypeKeys.MSG_OL_CUR_TRG_LOCKED :
                 * DisplayMatchTypeKeys.MSG_OL_CUR_TRG_UNLOCKED));
                 */
                break;
            case INDICATE_CURRENT_TARGET_SUB:
                // show nothing for current target sub
                msg = "";
                /*
                 * m_resources.getString(p_isProtected ?
                 * DisplayMatchTypeKeys.MSG_OL_CUR_TRG_SUB_LOCKED :
                 * DisplayMatchTypeKeys.MSG_OL_CUR_TRG_SUB_UNLOCKED);
                 */
                break;
            case INDICATE_CURRENT_TARGET_EXCLUDED:
                msg = m_resources
                        .getString(DisplayMatchTypeKeys.MSG_OL_CUR_TRG_EXCLUDED);
                break;
            case INDICATE_CURRENT_TARGET_SUB_EXCLUDED:
                msg = m_resources
                        .getString(DisplayMatchTypeKeys.MSG_OL_CUR_TRG_SUB_EXCLUDED);
                break;
            case INDICATE_EXACT:
                msg = m_resources
                        .getString(p_isProtected ? DisplayMatchTypeKeys.MSG_OL_EXACT_LOCKED
                                : DisplayMatchTypeKeys.MSG_OL_EXACT_UNLOCKED);
                break;
            case INDICATE_UNVERIFIED_EXACT:
                msg = m_resources
                        .getString(p_isProtected ? DisplayMatchTypeKeys.MSG_OL_UNVERIFIED_EXACT_LOCKED
                                : DisplayMatchTypeKeys.MSG_OL_UNVERIFIED_EXACT_UNLOCKED);
                break;
            case INDICATE_EXACT_SUB:
                msg = m_resources
                        .getString(p_isProtected ? DisplayMatchTypeKeys.MSG_OL_EXACT_SUB_LOCKED
                                : DisplayMatchTypeKeys.MSG_OL_EXACT_SUB_UNLOCKED);
                break;
            case INDICATE_UNVERIFIED_EXACT_SUB:
                msg = m_resources
                        .getString(p_isProtected ? DisplayMatchTypeKeys.MSG_OL_UNVERIFIED_EXACT_SUB_LOCKED
                                : DisplayMatchTypeKeys.MSG_OL_UNVERIFIED_EXACT_SUB_UNLOCKED);
                break;
            case INDICATE_FUZZY_TRADOS:
                forTrados = true;
                // intentional fall through
            case INDICATE_FUZZY_NORMAL:
                Object[] args =
                { "" + p_score };
                String tmp = m_resources
                        .getString(forTrados ? DisplayMatchTypeKeys.MSG_FUZZY_AND_SCORE
                                : DisplayMatchTypeKeys.MSG_OL_FUZZY_ANDSCORE_ANDNOTE);
                msg = MessageFormat.format(tmp, args);
                break;
            case INDICATE_NO_MATCH:
                msg = m_resources.getString(DisplayMatchTypeKeys.MSG_NOMATCH);
                break;
            default:
                break;
        }

        return msg;
    }

    // assumes the page contains an extracted file
    private ExtractedSourceFile getExtractedSourceFile(SourcePage p_page)
    {
        return (ExtractedSourceFile) p_page.getPrimaryFile();
    }

    private boolean isStartOfNewPara(Tuv p_tuv, long p_jobId)
    {
        if (m_lastPid == p_tuv.getTu(p_jobId).getPid())
        {
            return false;
        }

        m_lastPid = p_tuv.getTu(p_jobId).getPid();

        return true;
    }

    /**
     * Gets the corresponding set of fuzzy matches from selected reference tms.
     * Use zero for subId ("0") to get parent matches.
     * 
     * @since GBS-3776
     */
    private ArrayList getTMDataRefTmsForSegment(SegmentPair p_pair,
            String p_subId)
    {
        if (m_fuzzyMatchRefTmsMap == null)
        {
            return null;
        }

        ArrayList ts = (ArrayList) m_fuzzyMatchRefTmsMap.get(p_pair
                .getSourceTuv().getIdAsLong());

        if (ts == null)
        {
            return null;
        }

        ArrayList result = null;
        int i = 0;
        Iterator it = ts.iterator();

        // Get and filter matches by sub id.
        while (it.hasNext() && i < m_maxFuzzyNum)
        {
            LeverageMatch levMatch = (LeverageMatch) it.next();

            if (levMatch.getSubId().equals(p_subId))
            {
                if (result == null)
                {
                    result = new ArrayList(m_maxFuzzyNum);
                }

                result.add(levMatch);
                i++;
            }
        }

        if (result != null)
        {
            // make the order according to the score number
            SortUtil.sort(result, new Comparator<LeverageMatch>()
            {
                public int compare(LeverageMatch l1, LeverageMatch l2)
                {
                    if (l1 != null && l2 != null)
                    {
                        if (l1.getScoreNum() > l2.getScoreNum())
                        {
                            return -1;
                        }
                        else
                        {
                            return 1;
                        }
                    }
                    return 0;
                }
            });
        }

        return result;
    }

    /**
     * Get the corresponding set of fuzzy matches. Use zero for subId ("0") to
     * get parent matches.
     */
    private ArrayList getTMDataForSegment(SegmentPair p_pair, String p_subId)
    {
        if (m_fuzzyMatchMap == null)
        {
            return null;
        }

        ArrayList ts = (ArrayList) m_fuzzyMatchMap.get(p_pair.getSourceTuv()
                .getIdAsLong());

        if (ts == null)
        {
            return null;
        }

        ArrayList result = null;
        int i = 0;
        Iterator it = ts.iterator();

        // Get and filter matches by sub id.
        while (it.hasNext() && i < m_maxFuzzyNum)
        {
            LeverageMatch levMatch = (LeverageMatch) it.next();

            if (levMatch.getSubId().equals(p_subId))
            {
                if (result == null)
                {
                    result = new ArrayList(m_maxFuzzyNum);
                }

                result.add(levMatch);
                i++;
            }
        }

        if (result != null)
        {
            // make the order according to the score number
            SortUtil.sort(result, new Comparator<LeverageMatch>()
            {
                public int compare(LeverageMatch l1, LeverageMatch l2)
                {
                    if (l1 != null && l2 != null)
                    {
                        if (l1.getScoreNum() > l2.getScoreNum())
                        {
                            return -1;
                        }
                        else
                        {
                            return 1;
                        }
                    }
                    return 0;
                }
            });
        }

        return result;
    }

    /**
     * Get the corresponding set of term matches. Use zero for subId ("0") to
     * get parent matches.
     */
    private ArrayList getTermDataForSegment(SegmentPair p_pair)
    {
        ArrayList result = null;

        if (m_termResultSet != null)
        {
            result = m_termResultSet.getLeverageMatches(p_pair.getSourceTuv()
                    .getId(), 0L /* never subs in 4.2 */);
        }

        return result;
    }

    /**
     * Builds a map that contains the source subflow data: the map is keyed by
     * the subId, the value is a SubflowData object.
     */
    private HashMap makeSrcSubflowDataMap(SegmentPair p_pair, long jobId)
    {
        return makeSubflowDataMap(p_pair.getSourceTuv(),
                p_pair.getMergedTuIds(), jobId);
    }

    /**
     * Builds a map that contains the target subflow data: the map is keyed by
     * the subId, the value is a SubflowData object.
     */
    private HashMap makeTrgSubflowDataMap(SegmentPair p_pair, long p_jobId)
    {
        return makeSubflowDataMap(p_pair.getTargetTuv(),
                p_pair.getMergedTuIds(), p_jobId);
    }

    /**
     * Builds a map that contains the parent ptag under which a sub appears and
     * the sub data. The map is keyed by the subId. The value is a SubflowData
     * object.
     */
    private HashMap makeSubflowDataMap(Tuv p_tuv, List p_mergedTuIds,
            long p_jobId)
    {
        HashMap subflowDataMap = new HashMap();
        List parentsOfSubs = p_tuv.getSubflowParentsAsGxmlElements();
        ListIterator it1 = parentsOfSubs.listIterator();

        while (it1.hasNext())
        {
            // get a single parent-of-subs
            GxmlElement parentOfSubs = (GxmlElement) it1.next();
            // get subs under this parent tag
            List subs = parentOfSubs
                    .getDescendantElements(GxmlElement.SUB_TYPE);
            // build map
            ListIterator it2 = subs.listIterator();

            while (it2.hasNext())
            {
                String downloadTuId = null;
                Long downloadTuIdAsLong = null;
                String downloadSubId = null;
                int downloadSubIdAsInt = 0;

                // get ptag reference
                String parentOfSubTagName = OfflineEditHelper
                        .getParentOfSubTagName(parentOfSubs,
                                m_tagDisplayFormatID);
                GxmlElement sub = (GxmlElement) it2.next();

                // get download Tu and subflow ids
                // check if merged, if so revert to original ids for download
                String subId = sub.getAttribute(GxmlNames.SUB_ID);
                int subIdAsInt = Integer.parseInt(subId);
                if (m_mergeEnabled
                        && p_mergedTuIds != null
                        && subIdAsInt > AmbassadorDwUpConstants.SPLIT_MERGE_OFFSET_BASE)
                {
                    // download subid
                    downloadSubIdAsInt = subIdAsInt
                            % AmbassadorDwUpConstants.SPLIT_MERGE_OFFSET_BASE;
                    downloadSubId = Integer.toString(downloadSubIdAsInt);

                    // download tuid
                    int idx = (subIdAsInt / AmbassadorDwUpConstants.SPLIT_MERGE_OFFSET_BASE);
                    downloadTuIdAsLong = (Long) p_mergedTuIds.get(idx);
                    downloadTuId = downloadTuIdAsLong.toString();
                }
                else
                {
                    downloadSubId = Integer.toString(subIdAsInt);
                    downloadTuId = p_tuv.getTuId() > 0 ? String.valueOf(p_tuv
                            .getTuId()) : p_tuv.getTu(p_jobId).getIdAsLong()
                            .toString();
                }

                subflowDataMap.put(subId, new SubflowData(downloadSubId,
                        downloadTuId, sub, parentOfSubTagName));
            }
        }

        return subflowDataMap;
    }

    /*
     * Justify whether Populate/download source as target, with conditions: 1)
     * Don't "Populate 100% Target Segments", from offline download option. 2)
     * Don't "Populate Fuzzy Target Segments", from offline download option.
     */
    private boolean isPopulateSrcAsTrg(float p_targetScore)
    {
        return (p_targetScore == 100 && !populate100)
                || (p_targetScore > 0 && p_targetScore != 100 && !populateFuzzy);
    }

}
